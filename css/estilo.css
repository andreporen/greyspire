// ritual.js – WebGL fenda + assinatura corrompida + áudio + selo
document.addEventListener("DOMContentLoaded", () => {
  const seloBtn = document.getElementById("seloBtn");
  const perg = document.getElementById("pergaminho");
  const carta = document.getElementById("carta");
  const assinatura = document.getElementById("assinatura");
  const audioEl = document.getElementById("ritualAudio");
  const fxCanvas = document.getElementById("fxCanvas");

  const NAME = "Arcanista-mor Amaris Solun";
  const JUMBLE = "ᚠᚢᚦᚨᚱᚲᚹᚺᚾᛁ✦✶◇◆◈¤*ABCDxyz123";
  const BPM = 60; // pedido: 60 bpm
  let activated = false;

  // carregar textura do pergaminho do data attribute
  const bgSrc = perg.dataset.bg;
  if (bgSrc){
    const img = new Image();
    img.src = bgSrc;
    img.onload = () => { perg.style.backgroundImage = `url(${bgSrc})`; };
  }

  // ===== assinatura: construir runas instáveis =====
  function buildSignature(){
    assinatura.innerHTML = "";
    const wrap = document.createElement("span");
    wrap.className = "runes";
    for (const ch of NAME){
      const s = document.createElement("span");
      s.className = "rune";
      s.dataset.real = ch;
      s.textContent = (ch === " ") ? "\u00A0" : JUMBLE[Math.floor(Math.random()*JUMBLE.length)];
      wrap.appendChild(s);
    }
    assinatura.appendChild(wrap);
  }

  function startShuffle(revealTime = 2400){
    const spans = Array.from(assinatura.querySelectorAll(".rune"));
    const total = spans.length;
    let t0 = performance.now();
    const duration = revealTime;
    const it = setInterval(() => {
      const now = performance.now();
      const prog = Math.min(1, (now - t0) / duration);
      const revealCount = Math.floor(prog * total);
      for (let i=0;i<total;i++){
        const el = spans[i];
        if (el.dataset.real === " ") { el.textContent = "\u00A0"; continue; }
        if (i < revealCount) {
          el.textContent = el.dataset.real;
          el.style.transform = "translateY(0) scale(1)";
        } else {
          el.textContent = JUMBLE[Math.floor(Math.random()*JUMBLE.length)];
          el.style.transform = "translateY(-6px) scale(.96)";
        }
      }
      if (prog >= 1){ clearInterval(it); assinatura.classList.add("pulsando"); }
    }, 70);
  }

  // partícula rúnica
  function spark(){
    const rect = assinatura.getBoundingClientRect();
    const s = document.createElement("span");
    s.className = "spark";
    s.style.left = (rect.left + rect.width * (0.2 + Math.random()*0.6)) + "px";
    s.style.top  = (rect.top  + rect.height * (0.2 + Math.random()*0.6)) + "px";
    document.body.appendChild(s);
    setTimeout(()=> s.remove(), 1600);
  }

  // ===== WebGL: Fenda roxa dinâmica sobre a assinatura =====
  // Shader de ruído + rachaduras roxas, centrado na assinatura
  const fragShader = `
  precision highp float;
  uniform vec2 u_res;
  uniform float u_time;
  uniform vec2 u_center;   // centro (0..1) na tela
  uniform float u_strength;// 0..1 intensidade (pulsada)
  uniform vec3 u_color;    // cor base (roxo)
  // hash simples
  float hash(vec2 p){ return fract(sin(dot(p, vec2(127.1,311.7)))*43758.5453123); }
  float noise(vec2 p){
    vec2 i = floor(p);
    vec2 f = fract(p);
    float a = hash(i);
    float b = hash(i + vec2(1.0,0.0));
    float c = hash(i + vec2(0.0,1.0));
    float d = hash(i + vec2(1.0,1.0));
    vec2 u = f*f*(3.0-2.0*f);
    return mix(a, b, u.x) + (c-a)*u.y*(1.0-u.x) + (d-b)*u.x*u.y;
  }
  float fbm(vec2 p){
    float v=0.0;
    float a=0.5;
    for(int i=0;i<5;i++){
      v += a*noise(p);
      p *= 2.0;
      a *= 0.5;
    }
    return v;
  }
  void main(){
    vec2 uv = gl_FragCoord.xy / u_res.xy;
    // posição relativa ao centro (assinatura)
    vec2 d = uv - u_center;
    float r = length(d);

    // campo de energia: fbm animado
    float t = u_time * 0.35;
    float field = fbm(uv*3.0 + vec2(t*0.6, -t*0.4));
    // rachaduras radiais
    float angle = atan(d.y, d.x);
    float crack = smoothstep(0.0, 0.02, abs(sin(angle*12.0 + t*2.0)) - 0.92);

    // força concentrada perto do centro
    float vign = smoothstep(0.45, 0.0, r);
    float energy = clamp(field*0.8 + crack*1.5, 0.0, 1.0) * vign;

    // pulso de intensidade
    energy *= (0.4 + 0.6*u_strength);

    // cor roxa com variação
    vec3 col = u_color * (0.3 + 0.7*energy);
    // alpha suave
    float alpha = smoothstep(0.0, 0.25, energy) * 0.75;
    gl_FragColor = vec4(col, alpha);
  }`;

  // setup webgl
  let gl, program, u_res, u_time, u_center, u_strength, u_color;
  function initWebGL(){
    gl = fxCanvas.getContext("webgl", {premultipliedAlpha:false, alpha:true, antialias:true});
    if(!gl){ console.warn("WebGL não disponível."); return; }

    // redimensionar
    resizeCanvas();
    window.addEventListener("resize", resizeCanvas);

    const vsSource = `
      attribute vec2 a_pos;
      void main(){ gl_Position = vec4(a_pos, 0.0, 1.0); }
    `;
    const fsSource = fragShader;

    const vs = gl.createShader(gl.VERTEX_SHADER);
    gl.shaderSource(vs, vsSource); gl.compileShader(vs);
    const fs = gl.createShader(gl.FRAGMENT_SHADER);
    gl.shaderSource(fs, fsSource); gl.compileShader(fs);

    if(!gl.getShaderParameter(vs, gl.COMPILE_STATUS)){
      console.error(gl.getShaderInfoLog(vs)); return;
    }
    if(!gl.getShaderParameter(fs, gl.COMPILE_STATUS)){
      console.error(gl.getShaderInfoLog(fs)); return;
    }

    program = gl.createProgram();
    gl.attachShader(program, vs);
    gl.attachShader(program, fs);
    gl.linkProgram(program);
    if(!gl.getProgramParameter(program, gl.LINK_STATUS)){
      console.error(gl.getProgramInfoLog(program)); return;
    }
    gl.useProgram(program);

    const quad = new Float32Array([
      -1,-1,  1,-1, -1, 1,
       1,-1,  1, 1, -1, 1
    ]);
    const buf = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, buf);
    gl.bufferData(gl.ARRAY_BUFFER, quad, gl.STATIC_DRAW);
    const a_pos = gl.getAttribLocation(program, "a_pos");
    gl.enableVertexAttribArray(a_pos);
    gl.vertexAttribPointer(a_pos, 2, gl.FLOAT, false, 0, 0);

    // uniforms
    u_res = gl.getUniformLocation(program, "u_res");
    u_time = gl.getUniformLocation(program, "u_time");
    u_center = gl.getUniformLocation(program, "u_center");
    u_strength = gl.getUniformLocation(program, "u_strength");
    u_color = gl.getUniformLocation(program, "u_color");
    gl.uniform3f(u_color, 0.76, 0.0, 1.0); // roxo base (0.76,0,1)

    gl.enable(gl.BLEND);
    gl.blendFunc(gl.SRC_ALPHA, gl.ONE); // aditivo
  }

  function resizeCanvas(){
    const rect = perg.getBoundingClientRect();
    fxCanvas.width  = Math.floor(rect.width  * devicePixelRatio);
    fxCanvas.height = Math.floor(rect.height * devicePixelRatio);
    fxCanvas.style.width  = rect.width + "px";
    fxCanvas.style.height = rect.height + "px";
    if(gl){
      gl.viewport(0,0,fxCanvas.width, fxCanvas.height);
      gl.useProgram(program);
      gl.uniform2f(u_res, fxCanvas.width, fxCanvas.height);
    }
  }

  // atualiza centro do efeito (seguindo a assinatura)
  function getSignatureCenter(){
    const rectP = perg.getBoundingClientRect();
    const rectA = assinatura.getBoundingClientRect();
    const cx = ( (rectA.left + rectA.width/2) - rectP.left ) / rectP.width;
    const cy = ( (rectA.top + rectA.height/2) - rectP.top ) / rectP.height;
    return {x:cx, y:cy};
  }

  // força pulsada (60 bpm = 1s)
  function pulseStrength(t){
    // ciclo suave tipo "heart"
    const s = 0.55 + 0.45 * Math.abs(Math.sin(t*3.14159)); // 1s = ~PI escala
    return s;
  }

  // render loop
  let startTime = performance.now();
  function render(){
    if(!gl){ requestAnimationFrame(render); return; }
    const now = performance.now();
    const t = (now - startTime)/1000;

    gl.useProgram(program);
    gl.uniform1f(u_time, t);
    const c = getSignatureCenter();
    gl.uniform2f(u_center, c.x, 1.0 - c.y); // flip Y para GL
    gl.uniform1f(u_strength, pulseStrength(t));

    gl.drawArrays(gl.TRIANGLES, 0, 6);
    requestAnimationFrame(render);
  }

  // ===== Ativação principal =====
  perg.classList.remove("revealed");
  assinatura.style.opacity = "0";
  carta.setAttribute("aria-hidden","true");
  assinatura.setAttribute("aria-hidden","true");

  // iniciar WebGL
  initWebGL();
  requestAnimationFrame(render);

  // clique no selo
  seloBtn.addEventListener("click", async () => {
    if (activated) return;
    activated = true;

    seloBtn.classList.add("hidden");
    perg.classList.add("revealed");
    carta.setAttribute("aria-hidden","false");

    try { await audioEl.play(); } catch(e){ console.warn("Autoplay bloqueado:", e); }

    // respiração do pergaminho
    perg.classList.add("pulse");

    // assinatura
    buildSignature();
    assinatura.setAttribute("aria-hidden","false");
    assinatura.style.opacity = "1";
    startShuffle(2600);

    // partículas periódicas
    setInterval(()=> spark(), 1000);
  });
});

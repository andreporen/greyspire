<!-- 1. Substitua createCrawlText() -->
<script>
  // ... (código anterior até init)

  function createCrawlText() {
    if (!sdfTexture) sdfTexture = createPrecomputedSDFTexture();
    const isMobile = window.innerWidth < 768;
    const scale = isMobile ? 1.8 : 2.2;
    const width = 800 * scale;
    const height = 1800 * scale;
    const material = new THREE.ShaderMaterial({
      uniforms: {
        tSDF: { value: sdfTexture },
        uTime: { value: 0 },
        uBeat: { value: 0 },
        uResolution: { value: new THREE.Vector2(width, height) }
      },
      vertexShader: document.getElementById('vertexShader').textContent,
      fragmentShader: document.getElementById('sdfFragmentShader').textContent,
      transparent: true,
      side: THREE.DoubleSide
    });
    const geometry = new THREE.PlaneGeometry(width, height);
    textMesh = new THREE.Mesh(geometry, material);
    crawlGroup = new THREE.Group();
    crawlGroup.add(textMesh);
    crawlGroup.position.y = -height / 2 - 300;
    scene.add(crawlGroup);
    const visibleHeight = 2 * Math.tan(camera.fov * Math.PI / 180 / 2) * camera.position.z;
    targetDistance = height + visibleHeight * 0.7;
    totalDistance = 0;
  }

  function createPrecomputedSDFTexture() {
    const width = 800, height = 1800;
    const canvas = document.createElement('canvas');
    canvas.width = width; canvas.height = height;
    const ctx = canvas.getContext('2d');
    ctx.fillStyle = 'black'; ctx.fillRect(0,0,width,height);
    ctx.fillStyle = 'white';
    ctx.font = 'bold 36px "Uncial Antiqua", "Cinzel Decorative", "MedievalSharp", Georgia, serif';
    ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
    const lines = LOREM_IPSUM_ARCANO.split('\n').map(l=>l.trim()).filter(Boolean);
    let y = 100;
    lines.forEach(l => { ctx.fillText(l, width/2, y); y += 52; });

    const imageData = ctx.getImageData(0,0,width,height);
    const data = imageData.data;
    const sdf = new Uint8Array(width*height);
    for (let i=0; i<data.length; i+=4) sdf[i>>2] = data[i]>200 ? 255 : 0;
    const temp = new Uint8Array(sdf);
    for (let r=0; r<40; r++) {
      for (let y=0; y<height; y++) for (let x=0; x<width; x++) {
        const idx = y*width + x; let maxVal = temp[idx];
        for (let dy=-1; dy<=1; dy++) for (let dx=-1; dx<=1; dx++) {
          const nx=x+dx, ny=y+dy;
          if (nx>=0&&nx<width&&ny>=0&&ny<height) maxVal = Math.max(maxVal, temp[ny*width+nx]);
        }
        if (sdf[idx]===0 && maxVal>0) sdf[idx] = Math.max(0, maxVal-1);
      }
      temp.set(sdf);
    }
    const result = ctx.createImageData(width, height);
    for (let i=0; i<sdf.length; i++) { const v=sdf[i]; result.data[i*4]=v; result.data[i*4+1]=v; result.data[i*4+2]=v; result.data[i*4+3]=255; }
    ctx.putImageData(result,0,0);

    const tex = new THREE.CanvasTexture(canvas);
    tex.minFilter = tex.magFilter = THREE.LinearFilter;
    tex.needsUpdate = true;
    return tex;
  }

  // ... resto do código
</script>

<!-- 2. Substitua o shader -->
<script type="x-shader/x-fragment" id="sdfFragmentShader">
  uniform sampler2D tSDF;
  uniform float uTime;
  uniform float uBeat;
  uniform vec2 uResolution;
  varying vec2 vUv;
  void main() {
    vec2 uv = vUv;
    vec2 p = uv * 2.0 - 1.0;
    p.y += 0.3 * p.y * p.y * (1.0 - abs(p.x) * 0.3);
    p /= 1.0 + 0.3 * (p.y + 1.0) * 0.6;
    uv = p * 0.5 + 0.5;
    float wave = 0.01 * (1.0 + 2.0 * uBeat);
    uv.x += wave * sin(uv.y * 25.0 + uTime * 2.0);
    uv.x += wave * 0.5 * sin(uv.y * 40.0 + uTime * 3.0);
    float sdf = texture2D(tSDF, uv).r / 255.0;
    float alpha = smoothstep(0.45, 0.55, sdf);
    float glow = smoothstep(0.0, 0.6, sdf);
    vec3 color = mix(vec3(0.8), vec3(1.0), sin(uTime * 6.0) * 0.5 + 0.5);
    vec3 glowColor = vec3(0.7, 0.3, 1.0) * glow * (2.0 + uBeat);
    vec3 final = color * alpha * 3.0 + glowColor;
    gl_FragColor = vec4(final, alpha);
  }
</script>

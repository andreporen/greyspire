<!DOCTYPE html>
<html lang="pt-br">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"/>
  <title>O Pergaminho Arcano</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Cinzel+Decorative:wght@400;700&family=MedievalSharp&display=swap" rel="stylesheet">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/howler/2.2.3/howler.min.js"></script>
  <style>
    :root { --cor-arcana:#b24cff; }
    html, body {
      margin:0; padding:0; width:100%; height:100%;
      background:#000; color:#fff; font-family:'MedievalSharp', cursive;
      overflow:hidden;
    }
    #seal-container{
      position:fixed; top:50%; left:50%; transform:translate(-50%,-50%);
      width:160px; height:160px; display:flex; justify-content:center; align-items:center;
      cursor:pointer; z-index:20; pointer-events:auto;
    }
    #arcane-seal-img{
      width:120px; height:auto; pointer-events:auto;
      filter:drop-shadow(0 0 22px var(--cor-arcana));
      transition:opacity .4s ease-out, filter .4s ease-out;
    }
    #arcane-seal-img.clicked{ opacity:0; filter:drop-shadow(0 0 5px var(--cor-arcana)); }
    #three-canvas{ position:fixed; top:0; left:0; z-index:1; }
    #signature-container{
      display:none; opacity:0; position:fixed; bottom:10vh; left:50%;
      transform:translateX(-50%); z-index:10; text-align:center;
      font-size:1.2rem; font-family:'MedievalSharp', cursive;
      transition:opacity 1s ease-in;
      max-width:600px; line-height:1.35;
    }
    #signature{ color:#fff; }
  </style>
</head>
<body>
  <div id="seal-container">
    <img id="arcane-seal-img" src="./selo-arcano.png" alt="Selo Arcano">
  </div>
  <canvas id="three-canvas"></canvas>
  <div id="signature-container">
    <p id="signature">
O coração dispara antes que você perceba que deixou a carta cair. O papel atinge o chão, mas a sensação de contato não some com ele. Algo fica preso na sua cabeça, como se um pensamento entrasse sem pedir permissão. Não é visão, nem sonho. É lembrança de algo que você nunca viveu.<br><br>
A imagem vem inteira, sem construção, sem origem: uma taverna que você nunca viu, mas reconhece. Tábuas escuras, cheiro de ferrugem, luz baixa demais para ser aconchegante, mesas que já desistiram de permanecer retas. Ferrugem & Ossos. Velha Chama. O nome surge pronto, como se sempre estivesse guardado em algum ponto da sua mente que não era seu.<br><br>
Ninguém diz que você deve ir.<br>
Mas a sensação é de que você já está atrasado.
    </p>
  </div>

  <!-- VERTEX SHADER -->
  <script type="x-shader/x-vertex" id="vertexShader">
    varying vec2 vUv;
    void main(){
      vUv = uv;
      gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0);
    }
  </script>

  <!-- FRAGMENT SHADER (com digitação linha-a-linha) -->
  <script type="x-shader/x-fragment" id="fragmentShader">
    uniform sampler2D map;
    uniform float time;
    uniform vec3 glowColor;
    uniform float distortionStrength;
    uniform float revealPos;
    uniform float revealWidth;
    uniform float revealFeather;
    uniform float pulseBoost;

    uniform float lineReveal[32];
    uniform int   totalLines;

    varying vec2 vUv;

    float rand(vec2 co){ return fract(sin(dot(co.xy, vec2(12.9898,78.233))) * 43758.5453); }
    float movingWindow(float y, float center, float width, float feather){
      float halfW = width * 0.5;
      float dist = abs(y - center);
      return clamp(smoothstep(halfW + feather, halfW, dist), 0.0, 1.0);
    }

    void main(){
      vec2 uv = vUv;
      float bend = 0.35;
      vec2 p = uv * 2.0 - 1.0;
      p.y += bend * p.y * p.y;
      float perspective = 1.0 + bend * (p.y + 1.0) * 0.5;
      p /= perspective;
      vec2 warpedUv = p * 0.5 + 0.5;

      vec2 distortedUv = warpedUv;
      float noise = (rand(warpedUv * 10.0 + time * 0.5) - 0.5) * distortionStrength;
      distortedUv.x += sin(warpedUv.y * 15.0 + time * 8.0) * noise;
      distortedUv.y += cos(warpedUv.x * 15.0 + time * 7.0) * noise;

      vec4 texel = texture2D(map, clamp(distortedUv, 0.0, 1.0));

      float w = movingWindow(warpedUv.y, revealPos, revealWidth, revealFeather);

      float lineAlpha = 0.0;
      int lineIdx = int(floor((1.0 - warpedUv.y) * float(totalLines)));
      if (lineIdx >= 0 && lineIdx < totalLines) {
        lineAlpha = lineReveal[lineIdx];
      }

      float pulse = 0.6 + 0.4 * sin(time * 1.8);
      float centerBoost = smoothstep(0.18, 0.0, abs(warpedUv.y - revealPos));
      vec3 glow = glowColor * texel.a * (0.5 * pulse + pulseBoost * centerBoost * lineAlpha);

      float blackout = step(fract(time / 1.2), 0.07);
      vec3 base = vec3(1.0) * texel.a * w * lineAlpha;
      vec3 color = base + glow;
      color = mix(color, vec3(0.0), blackout * 0.45 * texel.a * w * lineAlpha);

      gl_FragColor = vec4(color, texel.a * w * lineAlpha);
    }
  </script>

  <script>
    const POEMA = `
Nas entranhas do real, onde a forma range,
eles caminham sem saber que já foram colhidos.
O mundo fede antes de morrer,
mas vós chamais isso de ordem.
Sob a pedra há dente,
sob o dente há fome,
sob a fome há ritmo,
e o ritmo vos aguarda.
Eles respiram, mas o ar não os quer.
A carne permanece, mas a lembrança apodrece.
O tempo só mastiga o que ainda resiste,
e nada resiste por muito.
O eixo tritura o que ousa lembrar.
A cidade dorme sobre ossos que não consentem.
Chama-se paz ao que sangra devagar,
chama-se vida ao que ainda não cedeu.
Vós sois as falhas do esquecimento,
os nomes que o silêncio não digeriu.
A Fenda não oferece escolha —
apenas retorno.
A vinda já começou
antes do passo.
A queda já vos guarda
antes da borda.
Ouçam.
Desçam.
Cedam.
Retornem.
A pele racha.
O selo abre.
A ruína respira.
E vos chama.`;

    let scene, camera, renderer, clock = new THREE.Clock();
    let sfx1, sfx2, sfx25, sfx3;
    let sfx2Id = null, sfx25Id = null;
    let crawlGroup, textMesh;
    let animationInProgress = false;
    let endThreshold = 0;
    const ARCANE_PURPLE = new THREE.Color('#b24cff');

    function init(){
      Howler.autoSuspend = false;
      setupAudio();
      setupScene();
      setupListeners();
    }

    function setupAudio(){
      sfx1  = new Howl({src:['./sfx1.mp3'],  volume:0.8, loop:false});
      sfx2  = new Howl({src:['./sfx2.mp3'],  volume:0.6, loop:true});
      sfx25 = new Howl({src:['./sfx2_5.mp3'],volume:1.0, loop:true});
      sfx3  = new Howl({src:['./sfx3.mp3'],  volume:0.6, loop:false});
    }

    function setupScene(){
      const canvas = document.getElementById('three-canvas');
      scene = new THREE.Scene();
      camera = new THREE.PerspectiveCamera(50, innerWidth/innerHeight, 1, 10000);
      camera.position.set(0,130,480);
      camera.lookAt(0,0,0);
      renderer = new THREE.WebGLRenderer({canvas, antialias:true, alpha:true});
      renderer.setSize(innerWidth, innerHeight);
      renderer.setPixelRatio(Math.min(devicePixelRatio,3));
    }

    function setupListeners(){
      document.getElementById('seal-container').addEventListener('click', startExperience, {once:true});
      addEventListener('resize', onWindowResize);
    }

    function startExperience(){
      if (animationInProgress) return;
      animationInProgress = true;
      Howler.ctx?.resume();

      document.getElementById('arcane-seal-img').classList.add('clicked');
      setTimeout(()=> document.getElementById('seal-container').style.display='none', 400);

      sfx1.play();
      sfx2Id  = sfx2.play();  sfx2.fade(0,0.6,3000,sfx2Id);
      sfx25Id = sfx25.play(); sfx25.fade(0,1.0,3000,sfx25Id);

      createCrawlText();
      animate();
    }

    function createCrawlText(){
      const rawLines = POEMA.trim().split('\n').filter(l=>l.trim());
      const totalLines = rawLines.length;

      const {canvas, cssWidth, cssHeight} = createTextCanvas(POEMA, totalLines);

      const texture = new THREE.CanvasTexture(canvas);
      texture.minFilter = THREE.LinearFilter;
      texture.magFilter = THREE.NearestFilter;
      texture.anisotropy = renderer.capabilities.getMaxAnisotropy();

      const material = new THREE.ShaderMaterial({
        uniforms: {
          map: {value: texture},
          time: {value: 0},
          glowColor: {value: ARCANE_PURPLE},
          distortionStrength: {value: 0.00605},
          revealPos: {value: -0.2},
          revealWidth: {value: 0.20},
          revealFeather: {value: 0.055},
          pulseBoost: {value: 0.42},
          lineReveal: {value: new Float32Array(32).fill(0)},
          totalLines: {value: totalLines}
        },
        vertexShader: document.getElementById('vertexShader').textContent,
        fragmentShader: document.getElementById('fragmentShader').textContent,
        transparent: true
      });

      const geometry = new THREE.PlaneGeometry(cssWidth, cssHeight);
      textMesh = new THREE.Mesh(geometry, material);
      crawlGroup = new THREE.Group();
      crawlGroup.add(textMesh);

      const startY = -cssHeight/2 - 280;
      crawlGroup.position.y = startY;
      endThreshold = cssHeight * 1.28 + 140;

      scene.add(crawlGroup);
      crawlGroup.userData = {startY, total: endThreshold-startY, totalLines};
    }

    function createTextCanvas(text, totalLines){
      const isMobile = innerWidth <= 480;
      let fontSize = isMobile ? 21 : 30;
      let lineHeight = fontSize * 1.32;
      let cssWidth = 1024;
      let cssHeight = totalLines * lineHeight + fontSize * 3;

      const maxH = innerHeight * 0.84;
      if (cssHeight > maxH){
        const s = maxH / cssHeight;
        fontSize *= s; lineHeight *= s; cssWidth *= s;
        cssHeight = totalLines * lineHeight + fontSize * 3;
      }

      const dpr = Math.min(devicePixelRatio||1, 3);
      const ss = 2;
      const canvas = document.createElement('canvas');
      canvas.width  = cssWidth  * dpr * ss;
      canvas.height = cssHeight * dpr * ss;
      const ctx = canvas.getContext('2d');
      ctx.scale(dpr*ss, dpr*ss);
      ctx.font = `700 ${fontSize}px 'Cinzel Decorative'`;
      ctx.fillStyle = '#fff';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'alphabetic';

      let y = fontSize * 2;
      text.trim().split('\n').filter(l=>l.trim()).forEach(line => {
        ctx.fillText(line, cssWidth/2, y);
        y += lineHeight;
      });

      return {canvas, cssWidth, cssHeight};
    }

    function animate(){
      requestAnimationFrame(animate);
      if (!animationInProgress) return;

      const t = clock.getElapsedTime();
      textMesh.material.uniforms.time.value = t;

      crawlGroup.position.y += 0.546;

      const progress = (crawlGroup.position.y - crawlGroup.userData.startY) / crawlGroup.userData.total;
      const sweep = -0.20 + progress * 1.40;
      const u = textMesh.material.uniforms;
      u.revealPos.value = sweep;

      // REVELAÇÃO LINHA-A-LINHA (efeito digitação)
      const lineReveal = u.lineReveal.value;
      const linesPerSecond = 2.8;
      const currentLine = Math.floor(progress * crawlGroup.userData.totalLines * 1.1);
      for (let i=0; i<32; i++){
        if (i < currentLine) lineReveal[i] = 1;
        else if (i === currentLine){
          lineReveal[i] = Math.min(1, (t * linesPerSecond) % 1);
        } else lineReveal[i] = 0;
      }
      u.lineReveal.value = lineReveal;

      // Batimento acelerando
      if (sfx25Id !== null && sfx25.playing(sfx25Id)){
        let rate = 1;
        if (progress>0.4) rate=1.10;
        if (progress>0.6) rate=1.20;
        if (progress>0.8) rate=1.30;
        if (progress>0.92) rate=1.38;
        if (progress>0.98) rate=1.45;
        sfx25.rate(rate, sfx25Id);
      }

      if (crawlGroup.position.y > endThreshold) finishAnimation();

      renderer.render(scene, camera);
    }

    function finishAnimation(){
      animationInProgress = false;
      [sfx2, sfx25].forEach(s=>{ s.fade(s.volume(),0,800); setTimeout(()=>s.stop(),820); });
      scene.remove(crawlGroup);
      textMesh.geometry.dispose();
      textMesh.material.uniforms.map.value.dispose();
      textMesh.material.dispose();

      const sig = document.getElementById('signature-container');
      sig.style.display = 'block';
      setTimeout(()=> sig.style.opacity='1', 200);
      setTimeout(()=> { Howler.ctx?.resume(); sfx3.play(); }, 1000);
    }

    function onWindowResize(){
      camera.aspect = innerWidth/innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(innerWidth, innerHeight);
    }

    init();
  </script>
</body>
</html>

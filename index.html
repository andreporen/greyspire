// Substitua createCrawlText() por:
function createCrawlText() {
  if (textMesh) {
    textMesh.dispose();
    if (crawlGroup) scene.remove(crawlGroup);
  }

  const isMobile = window.innerWidth < 768;
  const maxWidth = Math.min(window.innerWidth * 0.9, 800);
  const fontSize = Math.max(20, Math.min(36, Math.floor(window.innerHeight * 0.04)));

  const text = new Troika.Text();
  text.text = LOREM_IPSUM_ARCANO;
  text.font = 'https://fonts.gstatic.com/s/uncialantiqua/v21/b0ngw4-TgY2-q0WJu1gH0pJ14c2r2tWj5a8.woff2';
  text.fontSize = fontSize;
  text.color = 0xffffff;
  text.anchorX = 'center';
  text.anchorY = 'top';
  text.textAlign = 'center';
  text.maxWidth = maxWidth;
  text.lineHeight = 1.35;
  text.letterSpacing = 0.02;

  text.material = new THREE.ShaderMaterial({
    uniforms: {
      map: { value: null },
      time: { value: 0.0 },
      glowColor: { value: ARCANE_PURPLE },
      baseDistortion: { value: 0.010 },
      baseNoise: { value: 0.010 },
      beatLevel: { value: 0.0 }
    },
    vertexShader: document.getElementById('vertexShader').textContent,
    fragmentShader: document.getElementById('fragmentShader').textContent,
    transparent: true,
    side: THREE.DoubleSide
  });

  text.sync(() => {
    const bb = text.geometry.boundingBox;
    textHeight = bb.max.y - bb.min.y;
    const fovRad = camera.fov * Math.PI / 180;
    const visibleHeight = 2 * Math.tan(fovRad / 2) * camera.position.z;
    targetDistance = textHeight + visibleHeight * 0.7;
    totalDistance = 0;

    crawlGroup = new THREE.Group();
    crawlGroup.add(text);
    crawlGroup.position.y = -textHeight / 2 - 300;
    scene.add(crawlGroup);
    textMesh = text;
  });
}

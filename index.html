<!DOCTYPE html>
<html lang="pt-br">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover"/>
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="format-detection" content="telephone=no">
  <title>O Pergaminho Arcano</title>

    <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Cinzel+Decorative:wght@400;700&family=MedievalSharp&display=swap" rel="stylesheet">

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/howler/2.2.3/howler.min.js"></script>

  <style>
    :root { --cor-arcana: #b24cff; }

    html, body {
      margin: 0; padding: 0; width: 100%; height: 100%;
      background: #000; color: #fff;
      font-family: 'MedievalSharp', cursive;
      overflow: hidden;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
      text-rendering: optimizeLegibility;
      -webkit-tap-highlight-color: transparent;
      -webkit-touch-callout: none;
      -webkit-user-select: none;
      user-select: none;
    }

    /* Selo */
    #seal-container {
      position: fixed; top: 50%; left: 50%;
      transform: translate(-50%, -50%);
      width: 160px; height: 160px;
      display: flex; justify-content: center; align-items: center;
      cursor: pointer; z-index: 20; pointer-events: auto;
    }
    #arcane-seal-img {
      width: 120px; height: auto; pointer-events: auto;
      filter: drop-shadow(0 0 22px var(--cor-arcana));
      transition: opacity .4s ease-out, filter .4s ease-out;
      -webkit-transition: opacity .4s ease-out, filter .4s ease-out;
      -webkit-tap-highlight-color: transparent;
    }
    #arcane-seal-img.clicked {
      opacity: 0; filter: drop-shadow(0 0 5px var(--cor-arcana));
    }

    /* Canvas */
    #three-canvas {
      position: fixed; top: 0; left: 0; z-index: 1;
    }

    /* Interstitial */
    #interstitial {
      display: none; opacity: 0;
      position: fixed; inset: 0; z-index: 9;
      align-items: center; justify-content: center;
      pointer-events: none; background: transparent;
      transition: opacity .5s ease;
      -webkit-transition: opacity .5s ease;
    }
    #interstitial.show { opacity: 1; display: flex; }
    #interstitial.hide { opacity: 0; }

    .interstitial-text {
      max-width: 800px; padding: 0 24px; text-align: center;
      font-size: clamp(20px, 4vw, 36px); color: #fff;
      text-shadow: 
        0 0 10px var(--cor-arcana),
        0 0 20px var(--cor-arcana),
        0 0 30px var(--cor-arcana);
      animation: interstitialGlow 2.8s ease-in-out infinite;
      filter: brightness(1.05);
    }
    @keyframes interstitialGlow {
      0%, 100% { 
        text-shadow: 0 0 10px #fff, 0 0 18px var(--cor-arcana), 0 0 28px var(--cor-arcana); 
      }
      50% { 
        text-shadow: 0 0 16px #fff, 0 0 32px var(--cor-arcana), 0 0 50px var(--cor-arcana), 0 0 70px var(--cor-arcana); 
      }
    }

    /* Assinatura Final */
    #signature-container {
      display: none; opacity: 0;
      position: fixed; bottom: 110px; left: 50%;
      transform: translateX(-50%); z-index: 10;
      text-align: center; font-size: 1.2rem;
      font-family: 'MedievalSharp', cursive;
      transition: opacity 1.2s ease-in;
      -webkit-transition: opacity 1.2s ease-in;
      max-width: 600px; line-height: 1.35;
    }
    #signature {
      color: #fff;
      text-shadow: 
        0 0 6px #fff, 
        0 0 12px var(--cor-arcana), 
        0 0 18px var(--cor-arcana);
      animation: pulse-arcano 1.4s ease-in-out infinite;
    }
    @keyframes pulse-arcano {
      0%, 100% { 
        text-shadow: 0 0 6px #fff, 0 0 12px var(--cor-arcana), 0 0 18px var(--cor-arcana); 
      }
      50% { 
        text-shadow: 0 0 10px #fff, 0 0 22px var(--cor-arcana), 0 0 32px var(--cor-arcana), 0 0 45px var(--cor-arcana); 
      }
    }
  </style>
</head>
<body>

    <div id="seal-container">
    <img id="arcane-seal-img" src="./assets/selo-arcano.png" alt="Selo Arcano">
  </div>

    <canvas id="three-canvas"></canvas>

    <div id="interstitial">
    <div class="interstitial-text">Sua mente é preenchida por um fluxo de pensamentos</div>
  </div>

    <div id="signature-container">
    <p id="signature">
      O coração dispara antes que você perceba que deixou a carta cair. O papel atinge o chão, mas a sensação de contato não some com ele. Algo fica preso na sua cabeça, como se um pensamento entrasse sem pedir permissão. Não é visão, nem sonho. É lembrança de algo que você nunca viveu.<br><br>
      A imagem vem inteira, sem construção, sem origem: uma taverna que você nunca viu, mas reconhece. Tábuas escuras, cheiro de ferrugem, luz baixa demais para ser aconchegante, mesas que já desistiram de permanecer retas. Ferrugem & Ossos. Velha Chama. O nome surge pronto, como se sempre estivesse guardado em algum ponto da sua mente que não era seu.<br><br>
      Ninguém diz que você deve ir.<br>
      Mas a sensação é de que você já está atrasado.
    </p>
  </div>

    <script type="x-shader/x-vertex" id="vertexShader">
    varying vec2 vUv;
    void main() {
      vUv = uv;
      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
    }
  </script>

  <script type="x-shader/x-fragment" id="fragmentShader">
    uniform sampler2D map;
    uniform float time;
    uniform vec3 glowColor;
    uniform float distortionStrength; // Usaremos este uniforme para a força da distorção

    varying vec2 vUv;

    void main() {
      // Usa UVs planos (2D) para nitidez máxima (remove perspectiva 3D)
      vec2 warpedUv = vUv; 

      // Distorção de onda SUTIL e LENTA (máxima legibilidade)
      vec2 distortedUv = warpedUv;
      float d = distortionStrength;
      
      // Frequências baixas (4.0/3.0) e velocidade lenta (0.5/0.6)
      distortedUv.x += sin(warpedUv.y * 4.0 + time * 0.5) * d;
      distortedUv.y += cos(warpedUv.x * 3.0 + time * 0.6) * d;

      vec4 texel = texture2D(map, clamp(distortedUv, 0.0, 1.0));

      // Cor simples (branco + glow)
      vec3 colorText = vec3(1.0);
      vec3 glow = glowColor * texel.a * 0.45;

      vec3 color = colorText * texel.a + glow;
      gl_FragColor = vec4(color, texel.a);
    }
  </script>

  <script>
    /* ==================== CONFIGURAÇÕES GLOBAIS ==================== */
    const SETTINGS = {
      colors: { arcane: '#b24cff' },
      CRAWL_BASE: 0.60,        // velocidade mínima (garante que suba rápido)
      CRAWL_MAX: 1.15,         // velocidade máxima
      DISTORTION_BASE: 0.0002, // distorção sutil (base)
      DISTORTION_PEAK: 0.0025, // distorção sutil (pico da batida)
      DISTORTION_SYNC_WITH_BEAT: true,
    };

    function rateByProgress(p) {
      let rate = 1;
      if (p > 0.40) rate = 1.10;
      if (p > 0.60) rate = 1.20;
      if (p > 0.80) rate = 1.30;
      if (p > 0.92) rate = 1.38;
      if (p > 0.98) rate = 1.45;
      return rate;
    }

    /* ==================== BEAT & UTILS ==================== */
    let BEAT = { fps: 60, durationSec: 0, values: [], ready: false };
    
    function getBeatAt(timeSec) {
      if (!BEAT.ready || BEAT.values.length === 0) {
        return (Math.sin(timeSec * 2 * Math.PI * 1.0) * 0.5 + 0.5);
      }
      const t = timeSec % BEAT.durationSec;
      const idx = Math.floor(t * BEAT.fps) % BEAT.values.length;
      return BEAT.values[idx];
    }
    
    function getBeatMix(rate, time){
      const p = Math.sin(time * rate * (Math.PI * 2)) * 0.5 + 0.5;
      return Math.pow(p, 1.25);
    }
    
    // Função stub para precomputeBeat (usaremos getBeatMix)
    async function precomputeBeat(url) {
      // Em uma aplicação monolítica, não precisamos de pré-cálculo de arquivo.
      // Apenas garantimos que o sfx2_5 esteja pronto.
      BEAT.ready = true;
    }

    /* ==================== TEXTO ARCANO ==================== */
    const LOREM_IPSUM_ARCANO = `
Nas entranhas do real, onde a forma range,
eles caminham sem saber que já foram colhidos.
O mundo fede antes de morrer,
mas vós chamais isso de ordem.

Sob a pedra há dente,
sob o dente há fome,
sob a fome há ritmo,
e o ritmo vos aguarda.

Eles respiram, mas o ar não os quer.
A carne permanece, mas a lembrança apodrece.
O tempo só mastiga o que ainda resiste,
e nada resiste por muito.

O eixo tritura o que ousa lembrar.
A cidade dorme sobre ossos que não consentem.
Chama-se paz ao que sangra devagar,
chama-se vida ao que ainda não cedeu.

Vós sois as falhas do esquecimento,
os nomes que o silêncio não digeriu.
A Fenda não oferece escolha —
apenas retorno.

A vinda já começou
antes do passo.
A queda já vos guarda
antes da borda.

Ouçam.
Desçam.
Cedam.
Retornem.

A pele racha.
O selo abre.
A ruína respira.
E vos chama.
`.trim();

    /* ==================== VARIAVEIS GLOBAIS ==================== */
    let scene, camera, renderer;
    let sfx1, sfx2, sfx25, sfx3;
    let sfx2Id = null, sfx25Id = null;
    let crawlGroup, textMesh, textHeight;
    let animationInProgress = false;
    let scrollSpeed = 0.7; // Será dinâmico
    let totalDistance = 0;
    let targetDistance = 0;
    let clock = new THREE.Clock();
    let beatAccum = 0;

    const ARCANE_PURPLE = new THREE.Color(getComputedStyle(document.documentElement).getPropertyValue('--cor-arcana').trim());

    /* ==================== INICIALIZAÇÃO ==================== */
    function init() {
      setupAudio();
      setupScene();
      precomputeBeat('./assets/sfx2_5.mp3'); // Apenas inicia o loop de áudio.
      setupListeners();
      animate();
    }

    function setupAudio() {
      Howler.autoSuspend = false;
      Howler.mute(false);
      Howler.volume(1.0);
      sfx1 = new Howl({ src: ['./assets/sfx1.mp3'], volume: 0.8, loop: false, html5: false });
      sfx2 = new Howl({ src: ['./assets/sfx2.mp3'], volume: 0.6, loop: true, html5: false });
      sfx25 = new Howl({ src: ['./assets/sfx2_5.mp3'], volume: 1.0, loop: true, html5: false });
      sfx3 = new Howl({ src: ['./assets/sfx3.mp3'], volume: 0.6, loop: false, html5: false });
      // Lógica de desbloqueio
      [sfx1, sfx2, sfx25, sfx3].forEach(h =>
        h.once('playerror', (id) => { try { Howler.ctx.resume() } catch (e) { } try { h.play(id) } catch (e) { } })
      );
    }

    function setupScene() {
      const canvas = document.getElementById('three-canvas');
      scene = new THREE.Scene();

      const aspect = window.innerWidth / window.innerHeight;
      camera = new THREE.PerspectiveCamera(50, aspect, 1, 10000);
      camera.position.set(0, 130, 480);
      camera.lookAt(0, 0, 0);
      scene.add(camera);

      renderer = new THREE.WebGLRenderer({ 
        canvas, 
        antialias: true, 
        alpha: true,
      });
      renderer.setSize(window.innerWidth, window.innerHeight);
      // DPR limitado a 2.5 para nitidez no mobile (conforme pedido)
      renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2.5)); 
    }

    function setupListeners() {
      document.getElementById('seal-container').addEventListener('click', startExperience, { once: true });
      window.addEventListener('resize', onWindowResize);
    }

    /* ==================== FLOW DE EXPERIÊNCIA ==================== */
    function startExperience() {
      if (animationInProgress) return;
      
      const sealImg = document.getElementById('arcane-seal-img');
      sealImg.classList.add('clicked');
      
      // Toca som do clique e esconde selo
      sfx1.play();
      setTimeout(() => { document.getElementById('seal-container').style.display = 'none'; }, 400);

      // Mostra Intersticial (3000ms)
      showInterstitial(3000);

      // Inicia áudio e crawl após o intersticial
      setTimeout(() => {
        startCrawlSequence();
      }, 3500); // 3000ms de display + 500ms de fade-out
    }

    function startCrawlSequence() {
      animationInProgress = true;
      clock.start();
      
      // Inicia áudio de fundo
      sfx2Id = sfx2.play();
      sfx25Id = sfx25.play(); // Usaremos beat mix
      
      createCrawlText();
      // Não há typing, então o finish será baseado no scroll completo
    }

    function showInterstitial(ms) {
      const inter = document.getElementById('interstitial');
      inter.style.display = 'flex';
      
      requestAnimationFrame(() => inter.classList.add('show')); // Inicia fade-in
      
      setTimeout(() => {
        inter.classList.remove('show'); // Inicia fade-out
        setTimeout(() => {
          inter.style.display = 'none';
        }, 500); // Duração do fade-out
      }, ms); // Tempo de exibição
    }

    /* ================= DETECÇÃO EXATA DO FINAL ================= */
    function createCrawlText() {
      const textCanvas = createTextCanvas(LOREM_IPSUM_ARCANO);
      // Largura/Altura lógica é a dimensão do canvas / scale
      const scale = 2; // Hardcoded no createTextCanvas
      const logicalWidth = textCanvas.width / scale;
      const logicalHeight = textCanvas.height / scale;
      textHeight = logicalHeight;

      const texture = new THREE.CanvasTexture(textCanvas);
      texture.minFilter = THREE.LinearFilter;
      texture.magFilter = THREE.LinearFilter; // MANTÉM NITIDEZ COM DISTORÇÃO
        
      const material = new THREE.ShaderMaterial({
        uniforms: {
          map: { value: texture },
          time: { value: 0.0 },
          glowColor: { value: ARCANE_PURPLE },
          distortionStrength: { value: SETTINGS.DISTORTION_BASE }
        },
        vertexShader: document.getElementById('vertexShader').textContent,
        fragmentShader: document.getElementById('fragmentShader').textContent,
        transparent: true,
        side: THREE.DoubleSide
      });

      const geometry = new THREE.PlaneGeometry(logicalWidth, logicalHeight);
      textMesh = new THREE.Mesh(geometry, material);

      crawlGroup = new THREE.Group();
      crawlGroup.add(textMesh);
      crawlGroup.rotation.x = 0;

      const fovRad = camera.fov * Math.PI / 180;
      const visibleHeight = 2 * Math.tan(fovRad / 2) * camera.position.z;
      const safeMargin = visibleHeight * 0.15; // Margem para o texto começar antes de sair

      const startY = -textHeight / 2 - visibleHeight / 2 - safeMargin;
      crawlGroup.position.y = startY;

      targetDistance = textHeight + visibleHeight + safeMargin;
      totalDistance = 0;
      scene.add(crawlGroup);
    }

    function createTextCanvas(text) {
      const lines = text.split('\n').map(l => l.trim()).filter(l => l);
      
      // Largura base (Three.js)
      const maxWidth = 800; 
      const canvasWidth = maxWidth;

      // Lógica de Tamanho de Fonte para Mobile (Adaptada da versão modular)
      const availableHeight = window.innerHeight * 0.85;
      let fontSize = 25.6; // Valor base para mobile nítido
      const minFontSize = 18;
      
      // Ajuste primário baseado no número de linhas e altura disponível
      fontSize = Math.floor((availableHeight / lines.length) * 0.4);
      fontSize = Math.max(minFontSize, fontSize);
      
      const lineHeightFinal = fontSize * 1.25;
      const canvasHeight = lines.length * lineHeightFinal + fontSize * 1.5;

      // Renderização em ALTA RESOLUÇÃO (scale=2) para maior nitidez
      const scale = 2;
      const canvas = document.createElement('canvas');
      canvas.width = canvasWidth * scale;
      canvas.height = canvasHeight * scale;

      const ctx = canvas.getContext('2d', { alpha: true });
      ctx.scale(scale, scale);
      
      // **CRÍTICO: Nitidez** - Removido anti-aliasing e shadows
      ctx.imageSmoothingEnabled = false; 
      ctx.shadowBlur = 0;
      
      ctx.font = `700 ${fontSize}px 'Cinzel Decorative'`;
      ctx.fillStyle = '#FFFFFF';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';

      let y = fontSize * 1.5;
      for (const line of lines) {
        ctx.fillText(line, canvasWidth / 2, y);
        y += lineHeightFinal;
      }
      return canvas;
    }

    /* ==================== ANIMAÇÃO (COM PROGRESSÃO E DISTORÇÃO) ==================== */
    function animate() {
      requestAnimationFrame(animate);

      const dt = clock.getDelta();
      beatAccum += dt;
      
      const elapsedTime = clock.getElapsedTime();

      if (crawlGroup && animationInProgress) {
        const progress = Math.min(1, totalDistance / targetDistance);
        const rate = rateByProgress(progress);
        
        // Atualiza rate do SFX25
        if (sfx25Id !== null) sfx25.rate(rate, sfx25Id);

        // Lógica de Aceleração do Crawl (progressiva)
        const baseSpeed = SETTINGS.CRAWL_BASE;
        const maxSpeed = SETTINGS.CRAWL_MAX;
        const speed = baseSpeed + (maxSpeed - baseSpeed) * Math.pow(progress, 1.5);
        
        const move = speed;
        crawlGroup.position.y += move;
        totalDistance += move;

        // Lógica de Distorção Sutil (baseada no beat e progresso)
        if (textMesh && textMesh.material.uniforms) {
          const u = textMesh.material.uniforms;
          u.time.value = elapsedTime;

          const beatMix = SETTINGS.DISTORTION_SYNC_WITH_BEAT 
                        ? getBeatMix(rate, elapsedTime) 
                        : 0.5;
          
          const base = SETTINGS.DISTORTION_BASE;
          const peak = SETTINGS.DISTORTION_PEAK;
          
          // 80% batida + 20% progresso
          const k = 0.8 * beatMix + 0.2 * Math.pow(progress, 1.2);
          const dist = base + (peak - base) * k;
          
          u.distortionStrength.value = dist;
        }

        // FINAL DETECTADO
        if (totalDistance >= targetDistance) {
          finishAnimation();
        }
      }

      renderer.render(scene, camera);
    }

    /* ==================== FINALIZAÇÃO ==================== */
    function finishAnimation() {
      if (!animationInProgress) return;
      animationInProgress = false;

      if (crawlGroup) scene.remove(crawlGroup);

      // Fade out e stop SFX2 e SFX2_5
      [sfx2,sfx25].forEach(s=>{
        try{
          const id = s._sounds[0]? s._sounds[0]._id : null;
          if (id!==null) s.fade(s.volume(id), 0, 800, id);
          setTimeout(()=>{ try{s.stop()}catch(e){} }, 820);
        }catch(e){}
      });

      // TOCA SFX3 e mostra Assinatura
      setTimeout(() => {
        const signature = document.getElementById('signature-container');
        signature.style.display = 'block';
        requestAnimationFrame(() => {
          signature.style.opacity = '1';
        });
        sfx3.play();
      }, 100);
    }

    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2.5));
      if (crawlGroup) {
        createCrawlText(); // Recria o canvas de texto para ajustar o tamanho da fonte
      }
    }

    /* ==================== ÁUDIO UTILS (Mantidos) ==================== */
    let binauralTargets = [];
    function startBinauralLoop() {
      function frame() {
        const now = performance.now() / 1000;
        binauralTargets = binauralTargets.filter(target => {
          const { howl, soundId, speed, radius, jitter, t0 } = target;
          if (!howl.playing(soundId)) return false;
          const t = (now - t0) * (1.0 / Math.max(0.001, speed));
          const a = 2.3, b = 1.7;
          const x = Math.sin(a * t) * radius * (0.85 + 0.15 * Math.sin(t * 3.1));
          const y = (Math.sin(b * t * 0.7) * 0.25) + (Math.random() - 0.5) * 0.02 * jitter;
          const z = (Math.cos(a * t * 0.9) * 0.7) - 0.3 + (Math.random() - 0.5) * 0.02 * jitter;
          howl.pos(x, y, z, soundId);
          return true;
        });
        requestAnimationFrame(frame);
      }
      requestAnimationFrame(frame);
    }
    function makeBinaural(howl, soundId, opts = {}) {
      const speed = opts.speed ?? 1.4;
      const radius = opts.radius ?? 1.0;
      const jitter = opts.jitter ?? 0.3;
      howl.pannerAttr({ panningModel: 'HRTF', refDistance: 1, rolloffFactor: 0.9 }, soundId);
      howl.pos(0, 0, -0.3, soundId);
      binauralTargets.push({ howl, soundId, speed, radius, jitter, t0: performance.now() / 1000 });
    }
    // Removido Reverb e WakeLock para simplificar o código, mantendo o foco no crawl e mobile.

    /* ==================== INICIALIZAÇÃO FINAL ==================== */
    init();
  </script>
</body>
</html>
